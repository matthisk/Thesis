\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{csquotes}
\usepackage[final]{listings}
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}{
  keywords={break, case, catch, continue, debugger, default, delete, do, else, false, finally, for, function, if, in, instanceof, new, null, return, switch, this, throw, true, try, typeof, var, void, while, with},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  ndkeywords={class, export, boolean, throw, implements, import, this},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  sensitive=true
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}

\title{%
	Syntactic language extensions for Javascript: \\
	\large Transforming Ecmascript 6 to 5}

\author{Matthisk Heimensen}

\begin{document}
\lstset{language=Pascal}
	\maketitle
	\tableofcontents
\section{Taxonomy of language features}
Part of my research is the creation of a taxonomy of language features introduced in the ECMAScript 6 specification document. The taxonomy is created in regards to the transformations needed to transform the code to ECMAScript 5 compliant code with identical semantics.

\subsection{Dimensions}
The following dimensions are identified for all language extensions.

\paragraph{Transformation level}
At what level is the transformation performed, in other words what information is needed for this transformation. Possible only lexical information is needed for the transformation, however in most cases we expect to need information of the context-free syntax.

\paragraph{Purely semantic}
Is the extension purely in semantics, or are there differences in the syntax after transformation.

\paragraph{Scope}
What is the scope of a language extensions transformation rule(s). This can be one of the following: local-to-local, local-to-global, global-to-global, or global-to-local.

\paragraph{Syntactically type preserving}
Is the type of the transformed syntax element the same as it is before transformation (e.g. is an expression transformed to an expression, or to a list of statements)

\paragraph{Introduction of bindings}
Are new bindings introduced in the transformed code as opposed to the original code.

\paragraph{Depending on bindings (i.e. run-time code)}
Will the transformed code rely on function calls not introduced by the transformation itself but provided separately from the transformation suite.

\paragraph{Compositional}
...

\paragraph{Preconditions}
What are the preconditions that have to be met before execution of a transformation rule, to ensure validness of our transformation (e.g. all sub-terms have to be analyzed and transformed)

\paragraph{Restrictions on sub-terms}
Does the language extensions impose restrictions on the sub-terms used inside of the language extension. (e.g. are certain expressions not allowed in the nesting of a certain extension)

\paragraph{Analysis of sub-terms}
Are the non-terminals of our language extension analyzed and possibly transformed by the transformation rule.

\paragraph{Dependency on other extensions}
Can the language extensions be performed stand-alone or is there a dependency on one of the other extensions.

\paragraph{Backwards compatible}
Is the transformed code backwards compatible with ECMAScript 6 standard.

\paragraph{Dividable}
Is it possible to identify smaller transformation rules inside this language extension, that can be performed independently from one another.

\subsection{Taxonomy}

\subsubsection{Arrow Functions}
Arrow functions\cite[14.2]{SpecJS} are the new lambda-like function definitions inspired by Coffeescript and C\# notation. The functions body knows no lexical this binding but instead uses the binding of its parent lexical scope.

\begin{table}[h]
\centering
\caption{Extension transformation dimensions}
\label{arrow-function-table}
\begin{tabular}{@{}rc@{}}
\toprule
                                       & \multicolumn{1}{l}{\textbf{Arrow Functions}} \\ \midrule
\textbf{Transformation level}          & Context-free syntax                          \\
\textbf{Scope}                         & Local-to-local                               \\
\textbf{Syntactically type preserving} & Yes                                          \\
\textbf{Introducing bindings}          & Yes                                          \\%
\textbf{Depending on bindings}         & No                                           \\
\textbf{Compositional}                 & Yes                                          \\
\textbf{Analysis of sub-terms}          & Yes                                          \\
\textbf{Constraints on sub-terms}       & Yes                                           \\
\textbf{Preconditions}                 & Yes                                          \\
\textbf{Dependencies}                  & No                                           \\
\textbf{Backwards compatible}          & Yes                                          \\
\textbf{Dividable}                     & No                                           \\ \bottomrule
\end{tabular}
\end{table}

\paragraph{Analysis of sub-terms}
References to the arguments, sup
er and this keyword have to be identified in the ConciseBody of an ArrowFunction and renamed.
\\
\\
\blockquote[{\cite[14.2.16]{SpecJS}}]{An ArrowFunction does not define local bindings for \textbf{arguments}, \textbf{super}, \textbf{this}, or new.target. Any reference to arguments, super, or this within an ArrowFunction must resolve to a binding in a lexically enclosing environment.}
\\\\
An arrow function is transformed to an ES5 function which is wrapped in a self-calling function which receives its lexical enclosing scopes \textbf{super}, \textbf{this}, and \textbf{arguments} variables. The enclosing lexical scope is not polluted with new variable declarations. Keywords references are prepended with an underscore, only references in the current scope (i.e. no deeper scope) are renamed.

\begin{lstlisting}
var f = <Arrow Function>;
\end{lstlisting}

\begin{lstlisting}
var f = (function(_super,_arguments,_this) {
	return <Desugared Arrow Function>
})(super,arguments,this);
\end{lstlisting}

\paragraph{Constraints on sub-terms}
Use of the \textbf{yield} keyword is not allowed in an arrow functions ConciseBody. Arrow functions can not be generators and deep continuations are avoided.

\paragraph{Preconditions}
Before an arrow function can be transformed its ConciseBody should have been transformed. This to prevent the incorrect renaming of sub-terms (\textbf{super},\textbf{arguments},\textbf{this}), because they still fall in the same scope depth.

\begin{lstlisting}
var f = () => {
	() => this;
};
\end{lstlisting}

\begin{lstlisting}
var f = (function(_super,_arguments,_this) {
	return function() {	
		() => _this;
	};
})(super,arguments,this);
\end{lstlisting}

\subsubsection{Classes}
Class definitions\cite[14.5]{SpecJS} are introduced in ECMAScript 6 as a new feature to standardize inheritance model. Underneath the prototypal inheritance model is still used to create class declarations.
\begin{table}[h]
\centering
\caption{Extension transformation dimensions}
\label{classes-table}
\begin{tabular}{@{}rc@{}}
\toprule
                                       & \multicolumn{1}{l}{\textbf{Classes}} \\ \midrule
\textbf{Transformation level}          & Context-free syntax                          \\
\textbf{Scope}                         & Local-to-local                               \\
\textbf{Syntactically type preserving} & Yes                                          \\
\textbf{Introducing bindings}          & No                                          \\%
\textbf{Depending on bindings}         & Yes                                           \\
\textbf{Compositional}                 & Yes                                          \\
\textbf{Analysis of sub-terms}          & Yes                                          \\
\textbf{Constraints on sub-terms}       & Yes                                           \\
\textbf{Preconditions}                 & Yes                                          \\
\textbf{Dependencies}                  & No                                           \\
\textbf{Backwards compatible}          & Yes                                          \\
\textbf{Dividable}                     & No                                           \\ \bottomrule
\end{tabular}
\end{table}

\paragraph{Syntactically type preserving}
There are two types of class declarations, a direct declaration as a Statement, or an Expression declaration. They are both transformed to a construct of the same syntactical type.

\paragraph{Depending on bindings}
Several features of the class declaration as described in the specification demand some runtime. (e.g. the class methods being non enumerable)

\paragraph{Analysis of sub-terms}
References of \textbf{super} and a \textbf{super} call have to identified inside constructor or class methods. These are transformed to preserve the correct \textbf{this} binding.

\paragraph{Constraints on sub-terms}
The sub-terms of a class declaration are always executed in strict mode

\blockquote[{\cite[14.5]{SpecJS}}]{A ClassBody is always strict code.}

\paragraph{Preconditions}
Bodies of constructor and class methods should have been transformed before the class declaration itself is transformed. This to prevent incorrect transformation of the sub-term \textbf{super}.

\subsection{Destructuring}
Destructuring\cite[12.14.5]{SpecJS} is a new language construct to extract values from object or arrays with a single assignment. It can be used in multiple places among which parameters, variable declaration, and expression assignment.

\begin{table}[h]
\centering
\caption{Extension transformation dimensions}
\label{destructuring-table}
\begin{tabular}{@{}rc@{}}
\toprule
                                       & \multicolumn{1}{l}{\textbf{Classes}} \\ \midrule
\textbf{Transformation level}          & Context-free syntax                          \\
\textbf{Scope}                         & Local-to-local                               \\
\textbf{Syntactically type preserving} & No                                          \\
\textbf{Introducing bindings}          & Yes                                          \\%
\textbf{Depending on bindings}         & Yes                                           \\
\textbf{Compositional}                 & Yes                                          \\
\textbf{Analysis of sub-terms}          & Yes                                          \\
\textbf{Constraints on sub-terms}       & No                                           \\
\textbf{Preconditions}                 & No                                          \\
\textbf{Dependencies}                  & Yes                                           \\
\textbf{Backwards compatible}          & Yes                                          \\
\textbf{Dividable}                     & Yes                                           \\ \bottomrule
\end{tabular}
\end{table}

\paragraph{Syntactically type preserving}
The transformation is not syntactically type preserving in every situation. If the destructuring is used in a variable declaration the syntactic type is converted from $<Statement>$ to $<Statement*>$, because new bindings are introduced.

\paragraph{Dependencies}
Object destructuring supports the computed property notation of extended object literals (as discussed in section: \ref{object-literals}): 

\begin{lstlisting}
var qux = "key";
var { [qux] : a } = obj;
\end{lstlisting}

Destructuring thus has a dependency on extended object literal notation for this feature to work properly.

\paragraph{Dividable}
This language features consists of two types of destructuring, object destructurings, and array destructurings. These two different features can be transformed separately. 

\subsection{Extended object literals} \label{object-literals}

\bibliography{thesis}{}
\bibliographystyle{plain}
\end{document}
