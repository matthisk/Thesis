% !TEX root = ../main.tex
% Chapter Template

\chapter{Problem Analysis} % Main chapter title

\label{Chapter2}

\lhead{Chapter 2. \emph{Problem Analysis}}

\section{Motivation}
What are the reasons to create program transformations or extend current programming languages, as opposed to just creating entirely new programming languages? Extensible programming languages allow programmers to introduce custom language features as an extension on a base language.  There are two main reasons for programmers to use program transformations. \textit{"First, a programmer can define language extensions for language constructs that are missing in the base language"}~\cite{Erdweg2014a}, for example default parameters, type annotations, or list comprehensions in JavaScript. \textit{"Second, extensible programming languages serve as an excellent base for language embedding"}~\cite{Erdweg2014a} this refers to the embedding of domain-specific languages inside a host language, for example using HTML markup inside of JavaScript with JSX\footnote{\url{https://facebook.github.io/jsx/}}.

In this Thesis we focus on the first motivation for the extension of programming languages, to introduce missing language constructs to a base language. We will evaluate the language workbench (see section \ref{rascal}) for the task of creating such language extensions. How difficult is it to implement multiple language extensions integrate them together and at the same time deliver integration with the development environment of the programmer. How modular are these language extensions, is it easy or hard to add new language extensions on top of each other and on top of the base language.

JavaScript programmers are tied to use the version of JavaScript implemented in the majority of their end-users web-browsers, this is because JavaScript is an interpreted language (see section \ref{javascript}) run mostly inside of web-browsers. With compiled programming languages programmers have control over the version of the programming language standard they use, by selecting the corresponding version of a compiler. For this reason JavaScript programmers can benefit greatly from language extensions, they are either dependent on the manufacturers of web-browsers to implement and distribute a version of the web-browser with new JavaScript construct, or they can use program transformations to introduce and use new language constructs immediately.

\section{Research approach}
Our research is divided in two main parts an experiment and an evaluation. The experiment is an implementation of the ES6 specification as language extensions on top of ES5 JavaScript as a base language, this implementation is our research's artifact (see appendix \ref{AppendixA}), named \textit{\projectname}. It is implemented in the Rascal programming language (see section \ref{rascal}). Second, we evaluate the language workbench for the task of implementing language extensions. For this evaluation we compare our implementation against other implementations of the ES6 specification as program transformations.

\section{Expected results}
\begin{itemize}
	\item A taxonomy for language extensions
	\item Language extension suite implementing (a subset of) the ES 6 features
	\item A set of compatibility tests, testing our implementation against the specification document
	\item Eclipse IDE integration (syntax highlighting \& declared at hyperlinks) for new language features
	\item Set of engineering trade-offs applicable to implementing language extensions inside the language workbench
\end{itemize}

A set of language extensions for the JavaScript programming language created with the aid of a language workbench. First, we expect that the use of language workbench will reduce the amount of work needed to implement these language extensions. Second, we expect that the use of a language workbench will make our implementation more modular, making it easier to add additional language extensions on top of other extensions or on top of the base language. 

The taxonomy of language extensions and the categorization created with the help of this taxonomy will provide us with useful insights in the inner working of these language extensions as program transformations. And will help in establishing a view of the key characteristics of each language extension.

We expect to get insight into the engineering trade-offs of implementing language extensions inside the language workbench. What limitations does the workbench impose, where can we benefit from the power of a language workbench, and what are the generic problems of language extensions.

\section{Research questions}
The central research questions of this thesis are:

\begin{enumerate}
	\item How \textit{effective} is the language workbench for the task of implementing language extensions?
	\item How can independent program transformations be categorized?	
	% \item What are the cross-cutting concerns of any program transformations, and how can we take care of these concerns separate of the transformation code?
\end{enumerate}

\section{Related Work} \label{sec:related}
Many researchers have investigated the possibility to make programming languages extensible, be it through language extensions, compiler extensions, or syntax macros. Often their research also tries to extend the tools with which programmers write their code (i.e. IDEs). Here we discuss several different approaches to programming language extension presented in the past.

Object oriented programming languages are designed in such a way that libraries created in the language encapsulate knowledge (in semantics) of a specific domain for which the library is created. Programmers of such libraries are not allowed to encapsulate knowledge of the domain in syntax. To allow the extension of programming languages to encapsulate domain knowledge in syntax Eelco Visser created a system for language extension through concrete syntax named MetaBorg~\cite{Visser20024}. The system is realized through Syntax Definition Formalism~\cite{Heering1989} and the Stratego~\cite{Visser2001a} transformation language. The system is modular and composable this makes it possible to combine different language extensions. The paper discusses three domains which \textit{"suffer from misalignment between language notation and the domain: code generation, XML document generation, and graphical user-interface construction."}~\cite{Visser20024} To test MetaBorg, DSLs for these three domains are implemented and integrated with the Java programming language as a host language. The work of Visser relates closely to \projectname presented in this thesis, with the major exception that MetaBorg is created with a dedicated set of tools and not inside a language workbench. Visser ignores the issues related to introduction of new bindings (i.e. variable capture). MetaBorg is not evaluated by quantitative measures against other tools for language extension.

Another system based on SDF and Stratego is presented by Erdweg et. al.~\cite{Erdweg} called Sugar*. This is a system for language extension agnostic from the base language, the system can extend- syntax, editor support, and static analysis. In contrast to the system presented in this thesis, Sugar* relies on information from a compiler of the base language to operate correctly. To evaluate the Sugar* system measures based on lines of code are applied to language extensions created for five different base languages (Java, Haskell, Prolog, JavaScript, and System F$_{\omega}$). Sugar* uses Spoofax to create editor support for language extensions, similar to a language workbench. Sugar* is based on SugarJ~\cite{Erdweg2011}, a library based language extension tool for the Java programming language. SugarJ is evaluated against other forms of syntactic embedding on five dimensions defined as design goals for SugarJ. They compare against string encoding, pure embedding, macro systems, extensible compilers, program transformations, and dynamic meta-object protocols.

All the tools discussed above (MetaBorg, Sugar*, and SugarJ) rely for their evaluation on a very small subset of actual implemented language extensions, where most are based on embedding a domain-specific language in a host language. In this thesis we try to evaluate the language workbench for the job of language extensions with the help of a large set of implemented extensions not based on embedding domain-specific languages but introducing new language features.  

The extension of the JavaScript programming language is studied by Disney et. al. ~\cite{Disney2014}, here JavaScript is extended through the use of syntax macros instead of separate language extensions. Their work focuses more on separating the parser and lexer to avoid ambiguities during parsing (a problem we avert by using a scannerless parser see section \ref{parsing}). They give no evaluation of the expressiveness of the resulting macro system. A project trying to implement ES6 features as macros using their macro system exists but is abandoned\footnote{\url{https://github.com/jlongster/es6-macros}}

In related work of our taxonomy of language extensions (see chapter \ref{Chapter4}) we can identify several categorizations of program transformations. For example the Irvine program transformation catalog~\cite{Standish1976a} presents a categorization for program transformations of lower-level procedural programming languages (e.g. the C programming language). Visser~\cite{Visser2001} presents a taxonomy for program transformations, which we partly reuse in our taxonomy of language extensions, his approach is more generic and they aim to categorize all types of transformations, not only those needed for language extension.

Erdweg et. al.~\cite{Erdweg2014} present the \textit{name-fix} algorithm, a generic language agnostic algorithm that can solve the issue of variable capture that arises after program transformations stand-alone from transformation code. In this thesis we reuse a similar system to ensure no variable capture arises during transformation. Erdweg et. al. proof the correctness of their implementation, something we have not performed for the implementation we reuse. A survey of domain-specific language implementations gives valuable insight into variable capture to be found in program transformations. Transformation hygiene has also received a lot of attention in the domain of syntax macros~\cite{Kohlbecker1986,Herman2010a,Disney2014}. 
