% !TEX root = ../main.tex
% Chapter 1

\chapter{Introduction and Motivation}

\label{Chapter1}

\lhead{Chapter 1. \emph{Introduction}}

Language extension allow programmers to introduce new language constructs to a base language, with two main purposes. \textit{``First a programmer can define language extensions for language constructs that are missing in the base language''}~\cite{Erdweg2014a}, these \textit{missing} constructs can range from more advanced looping constructs (e.g. \textit{foreach}/\textit{for-of} loops) to shorthand function notation (e.g. lambda functions). \textit{``Second, extensible programming languages serve as an excellent base for language embedding''}~\cite{Erdweg2014a} for instance enable the use a markup language (e.g. HTML) inside a programming language. Program transformations is one of the techniques to implement language extensions, they are used to transform language extensions from the source program to base language code. Many systems for program transformation exist but in recent years a specific type of tool has become more popular for this job, the language workbench. This tool aids the (meta-)programmer in creating meta-programs that integrate with modern IDEs. In this thesis we investigate the ability of language workbenches in helping the meta-programmer to create a large set of language extensions. 

As an experiment we extend the JavaScript programming language with features introduced by the new specification document of the language, ECMAScript 6 (ES6). The current specification of JavaScript implemented in all major run-times (be it web-browser or dedicated) is ECMAScript 5 (ES5). The language extensions are created with the Rascal~\cite{Klint} language workbench and the resulting tool is named \projectname{}. A second contribution of this thesis is a taxonomy for language extensions. With this taxonomy we try to capture the distinctive characteristics of each language extension in a generic way. With the help of this taxonomy we try to answer the following questions: How can the language extension be implemented, what information does transformation of a language extension require, and what are guarantees can we give of the target program produced by a language extension?

To evaluate the language workbench for the task of extending programming languages through language extensions we implement the latest JavaScript specification (ES6) as a set of language extensions on top of current JavaScript. Because of the popularity of the JavaScript programming language there already exist several implementations of ES6 as language extensions for ES5 JavaScript, implemented without the help of a language workbench, we use these implementations to evaluate the effectiveness of the language workbench. Measures used to evaluate our implementation 

are based on coverage of the transformation suite (i.e. amount of ES6 features implemented by the transformer), correctness of the transformations, size (i.e. source lines of code), modularity of the language extension suite, and noise generated by the transformation.

The Rascal language workbench made it possible for us to implement ES6 language extensions in a short time period with fewer lines of code. We cover almost all new language features from ES6 in \projectname, something only other large-scale open-source projects are able to achieve. We deliver editor support for reference hyperlinking, undeclared reference errors, illegal redeclaration errors, and hover documentation preview of target program. The language workbench does however constraint us to one specific IDE and our solution is less portable than other implementations. Syntax definition of the language workbench constrained us from implementing empty element matching in the destructuring (see appendix \ref{destructuring}) language extension of ES6 (see appendix \ref{AppendixA}).

\section{Outline}
This thesis is structured as follows. In chapter \ref{Chapter2} we present an analysis of the problem studied in this thesis. Chapter \ref{Chapter3} presents background information of program transformations and the language workbench. In chapter \ref{Chapter4} we present a taxonomy for language extensions.  Chapter \ref{Chapter5} discusses the implementation of \projectname. In chapter \ref{Chapter6} we evaluate our implementation against other implementations. Finally we conclude in chapter \ref{Chapter7}.