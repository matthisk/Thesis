Automatically generated by Mendeley Desktop 1.14
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Preferences -> BibTeX in Mendeley Desktop

@article{Omar2014,
author = {Omar, Cyrus and Kurilova, Darya and Nistor, Ligia and Chung, Benjamin and Potanin, Alex and Aldrich, Jonathan},
file = {:Users/matthisk/Downloads/chp\%3A10.1007\%2F978-3-662-44202-9\_5.pdf:pdf},
keywords = {bidirectional typechecking,extensible languages,parsing},
pages = {105--130},
title = {{Safely Composable Type-Specific Languages}},
year = {2014}
}
@incollection{Inostroza2014,
author = {Inostroza, Pablo and van der Storm, Tijs and Erdweg, Sebastian},
doi = {10.1007/978-3-319-08789-4\_12},
file = {:Users/matthisk/Google Drive/Studie/Master/Msc Thesis/Papers/Tracing program transformations with string origins.pdf:pdf},
pages = {154--169},
title = {{Tracing Program Transformations with String Origins}},
url = {http://link.springer.com/10.1007/978-3-319-08789-4\_12},
year = {2014}
}
@misc{Landin1966,
abstract = {A family of unimplemented computing languages is described that is intended to span differences of application area by a unified framework. This framework dictates the rules about the uses of user-coined names, and the conventions about characterizing functional relationships. Within this framework the design of a specific language splits into two independent parts. One is the choice of written appearances of programs (or more generally, their physical representation). The other is the choice of the abstract entities (such as numbers, character-strings, list of them, functional relations among them) that can be referred to in the language. The system is biased towards ``expressions'' rather than ``statements.'' It includes a nonprocedural (purely functional) subsystem that aims to expand the class of users' needs that can be met by a single print-instruction, without sacrificing the important properties that make conventional right-hand-side expressions easy to construct and understand.},
author = {Landin, P. J.},
booktitle = {Communications of the ACM},
doi = {10.1145/365230.365257},
file = {:Users/matthisk/Library/Application Support/Mendeley Desktop/Downloaded/Landin - 1966 - The next 700 programming languages.pdf:pdf},
issn = {00010782},
number = {3},
pages = {157--166},
title = {{The next 700 programming languages}},
volume = {9},
year = {1966}
}
@article{Erdweg2014,
abstract = {Program transformations in terms of abstract syntax trees compromise referential integrity by introducing variable capture. Variable capture occurs when in the generated program a variable declaration accidentally shadows the intended target of a variable reference. Existing transformation systems either do not guarantee the avoidance of variable capture or impair the implementation of transformations. We present an algorithm called name-fix that automatically eliminates variable capture from a generated program by systematically renaming variables. name-fix is guided by a graph representation of the binding structure of a program, and requires name-resolution algorithms for the source language and the target language of a transformation. name-fix is generic and works for arbitrary transformations in any transformation system that supports origin tracking for names. We verify the correctness of name-fix and identify an interesting class of transformations for which name-fix provides hygiene. We demonstrate the applicability of name-fix for implementing capture-avoiding substitution, inlining, lambda lifting, and compilers for two domain-specific languages.},
address = {Berlin, Heidelberg},
archivePrefix = {arXiv},
arxivId = {1404.5770},
author = {Erdweg, Sebastian and van der Storm, Tijs and Dai, Yi},
editor = {Jones, Richard},
eprint = {1404.5770},
file = {:Users/matthisk/Google Drive/Studie/Master/Msc Thesis/Papers/Name fix.pdf:pdf},
month = apr,
pages = {1--29},
publisher = {Springer Berlin Heidelberg},
series = {Lecture Notes in Computer Science},
title = {{Capture-Avoiding and Hygienic Program Transformations (incl. Proofs)}},
url = {http://link.springer.com/10.1007/978-3-662-44202-9 http://arxiv.org/abs/1404.5770},
volume = {8586},
year = {2014}
}
@article{Mens2006,
author = {Mens, Tom and {Van Gorp}, Pieter},
doi = {10.1016/j.entcs.2005.10.021},
file = {:Users/matthisk/Google Drive/Studie/Master/Msc Thesis/Papers/A Taxonomy of Model Transformations.pdf:pdf},
issn = {15710661},
journal = {Electronic Notes in Theoretical Computer Science},
keywords = {MDD,MDE,comparison,mdd,mde,model transformation,taxonomy},
month = mar,
number = {1},
pages = {125--142},
publisher = {Elsevier B.V.},
title = {{A Taxonomy of Model Transformation}},
url = {http://linkinghub.elsevier.com/retrieve/pii/S1571066106001435},
volume = {152},
year = {2006}
}
@article{Felleisen1990,
abstract = {The literature on programming languages contains an abundance of informal claims on the relative expressive power of programming languages, but there is no framework for formalizing such statements nor for deriving interesting consequences. As a first step in this direction, we develop a formal notion of expressiveness and investigate its properties. To validate the theory, we analyze some widely held beliefs about the expressive power of several extensions of functional languages. Based on these results, we believe that our system correctly captures many of the informal ideas on expressiveness, and that it constitutes a foundation for further research in this direction. 1 Comparing Programming Languages The literature on programming languages contains an abundance of informal claims on the expressive power of programming languages. Arguments in these contexts typically assert the expressibility or non-expressibility of programming constructs relative to a language. Unfortunately, pro...},
author = {Felleisen, Matthias},
doi = {10.1016/0167-6423(91)90036-W},
file = {:Users/matthisk/Library/Application Support/Mendeley Desktop/Downloaded/Felleisen - 1990 - On the Expressive Power of Programming Languages.pdf:pdf},
issn = {01676423},
journal = {Science of Computer Programming},
pages = {131 -- 151},
title = {{On the Expressive Power of Programming Languages}},
year = {1990}
}
@article{Zenger2001,
abstract = {New extensions to programming languages are constantly$\backslash$nbeing proposed. But implementing these extensions usually turns out$\backslash$nto be a very difficult and expensive task, since conventional compilers$\backslash$noften lack extensibility and reusability. In this paper we present$\backslash$nsome fundamental techniques to implement extensible compilers in an$\backslash$nobject-oriented language. For being able to implement extensible compiler$\backslash$npasses, we introduce an extensible form of algebraic datatypes. Our$\backslash$nextensible algebraic datatypes with defaults yield a simple programming$\backslash$nprotocol for implementing extensible and reusable compiler passes in a$\backslash$nfunctional style. We propose an architectural design pattern Context-$\backslash$nComponent which is specifically targeted towards building extensible,$\backslash$nhierarchically composed systems. Our software architecture for extensible$\backslash$ncompilers combines the use of algebraic types, known from functional$\backslash$nlanguages, with this object-oriented design pattern. We show that this$\backslash$napproach enables us to extend existing compilers flexibly without modifying$\backslash$nany source code. Our techniques have been successfully applied in$\backslash$nthe implementation of the extensible Java compiler JaCo.},
author = {Zenger, Matthias and Odersky, Martin},
file = {:Users/matthisk/Downloads/10.1.1.18.6194.pdf:pdf},
journal = {In ECOOP Workshop on Multiparadigm Programming with Object-Oriented Languages},
pages = {61--80},
title = {{Implementing Extensible Compilers}},
year = {2001}
}
@article{Erdweg2011,
abstract = {Existing approaches to extend a programming language with syntactic sugar often leave a bitter taste, because they cannot be used with the same ease as the main extension mechanism of the programming language - libraries. Sugar libraries are a novel approach for syntactically extending a programming language within the language. A sugar library is like an ordinary library, but can, in addition, export syntactic sugar for using the library. Sugar libraries maintain the composability and scoping properties of ordinary libraries and are hence particularly well-suited for embedding a multitude of domain-specific languages into a host language. They also inherit self-applicability from libraries, which means that sugar libraries can provide syntactic extensions for the definition of other sugar libraries. To demonstrate the expressiveness and applicability of sugar libraries, we have developed SugarJ, a language on top of Java, SDF and Stratego, which supports syntactic extensibility. SugarJ employs a novel incremental parsing technique, which allows changing the syntax within a source file. We demonstrate SugarJ by five language extensions, including embeddings of XML and closures in Java, all available as sugar libraries. We illustrate the utility of self-applicability by embedding XML Schema, a metalanguage to define XML languages.},
author = {Erdweg, Sebastian and Rendel, Tillmann},
doi = {10.1145/2048066.2048099},
file = {:Users/matthisk/Library/Application Support/Mendeley Desktop/Downloaded/Erdweg, Rendel - 2011 - SugarJ Library-based syntactic language extensibility.pdf:pdf},
isbn = {9781450309400},
issn = {0362-1340},
journal = {Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications},
keywords = {dsl embedding,language composition,language extensibility,libraries,sugarj,syntactic sugar},
number = {iii},
pages = {391--406},
title = {{SugarJ: Library-based syntactic language extensibility}},
url = {http://dl.acm.org/citation.cfm?id=2048099},
year = {2011}
}
@article{Visser2001a,
author = {Visser, Eelco},
file = {:Users/matthisk/Library/Application Support/Mendeley Desktop/Downloaded/Visser - 2001 - Stratego A Language for Program Transformation based on Rewriting Strategies.pdf:pdf},
isbn = {3-540-42117-3},
journal = {Computer},
number = {May},
pages = {357--361},
title = {{Stratego: A Language for Program Transformation based on Rewriting Strategies}},
volume = {2051},
year = {2001}
}
@article{Erdweg2014a,
author = {Erdweg, Sebastian and Rieger, Felix},
doi = {10.1145/2637365.2517210},
file = {:Users/matthisk/Google Drive/Studie/Master/Msc Thesis/Papers/A framework for extensible languages.pdf:pdf},
isbn = {9781450323734},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {15,5,compiler framework,language,macros,macros exist for many,module system,racket,such as scheme,sugarj,syntactic extensibility},
month = mar,
number = {3},
pages = {3--12},
title = {{A framework for extensible languages}},
url = {http://dl.acm.org/citation.cfm?doid=2637365.2517210},
volume = {49},
year = {2014}
}
@article{Feldthaus2011,
address = {New York, New York, USA},
author = {Feldthaus, Asger and Millstein, Todd and M\o ller, Anders and Sch\"{a}fer, Max and Tip, Frank},
doi = {10.1145/2048066.2048078},
file = {:Users/matthisk/Google Drive/Studie/Master/Msc Thesis/Papers/Tool-supported Refactoring for JavaScript.pdf:pdf},
isbn = {9781450309400},
journal = {Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications - OOPSLA '11},
pages = {119},
publisher = {ACM Press},
title = {{Tool-supported refactoring for JavaScript}},
url = {http://dl.acm.org/citation.cfm?doid=2048066.2048078},
year = {2011}
}
@article{Ward1994,
annote = {Basically about developing a domain specific language for your problem domain (with formal specification). Once the specification is layed out you start developing the actual program and the implementation/compiler at the same time (middle out). Problems are the difficulty of designing languages, advantages are the ease of programming and the better understanding of domain knowledge among developers.},
author = {Ward, M P},
file = {:Users/matthisk/Google Drive/Studie/Master/Msc Thesis/Papers/Language Oriented Programming (sweet-js).pdf:pdf},
journal = {Software-Concepts and Tools},
keywords = {domain oriented,language oriented programming,languages,rapid prototyping,reuse,user-enhanceable systems,very high level languages},
number = {4},
pages = {1--22},
title = {{Language Oriented Programming}},
volume = {15},
year = {1994}
}
@article{Visser1997,
author = {Visser, Eelco},
file = {:Users/matthisk/Library/Application Support/Mendeley Desktop/Downloaded/Visser - 1997 - Scannerless Generalized-LR Parsing.pdf:pdf},
number = {P9707},
title = {{Scannerless Generalized-LR Parsing}},
year = {1997}
}
@book{Standish1976a,
author = {Standish, T a and Harriman, a and Kibler, D and Neighbors, J M},
file = {:Users/matthisk/Google Drive/Studie/Master/Msc Thesis/Papers/The Irvine Program Transformation Guide.pdf:pdf},
title = {{The Irvine Program Transformation Catalogue}},
year = {1976}
}
@article{Erdweg,
author = {Erdweg, Sebastian and Storm, Tijs Van Der and V\"{o}lter, Markus and Boersma, Meinte and Bosman, Remi and Cook, William R and Gerritsen, Albert and Hulshout, Angelo and Kelly, Steven and Loh, Alex and Konat, Gabri\"{e}l D P and Molina, Pedro J and Palatnik, Martin and Pohjonen, Risto and Schindler, Eugen and Schindler, Klemens and Solmi, Riccardo},
file = {:Users/matthisk/Google Drive/Studie/Master/Msc Thesis/Papers/The state of the art in language workbenches.pdf:pdf},
pages = {197--217},
title = {{The State of the Art in Language Workbenches Conclusions from the Language Workbench Challenge}}
}
@misc{Visser2003,
author = {Visser, Eelco},
file = {:Users/matthisk/Google Drive/Studie/Master/Msc Thesis/Papers/A Taxonomy of Program Transformations.pdf:pdf},
pages = {1--35},
title = {{A Taxonomy of Program Transformation}},
year = {2003}
}
@inproceedings{Savary-Belanger2013,
author = {Savary-Belanger, Olivier and Monnier, Stefan and Pientka, Brigitte},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-319-03545-1\_16},
file = {:Users/matthisk/Google Drive/Studie/Master/Msc Thesis/Papers/Programming Type-Safe transformations using Higher-Order Abstract Syntax.pdf:pdf},
isbn = {9783319035444},
issn = {03029743},
pages = {243--258},
title = {{Programming type-safe transformations using higher-order abstract syntax}},
volume = {8307 LNCS},
year = {2013}
}
@article{Pombrio2014,
abstract = {...We address this problem by showing how to compute reduction steps in terms of the surface syntax. Each step in the surface lan- guage emulates one or more steps in the core language. The com- puted steps hide the transformation, thus maintaining the abstrac- tion provided by the surface language. We make these statements about emulation and abstraction precise, prove that they hold in our formalism, and verify part of the system in Coq...},
author = {Pombrio, Justin and Krishnamurthi, Shriram},
doi = {10.1145/2594291.2594319},
file = {:Users/matthisk/Library/Application Support/Mendeley Desktop/Downloaded/Pombrio, Krishnamurthi - 2014 - Resugaring lifting evaluation sequences through syntactic sugar.pdf:pdf},
isbn = {9781450327848},
issn = {15232867},
journal = {Pldi},
keywords = {debugging,evaluation,macros,programming languages,resugaring,syntactic sugar},
pages = {361--371},
title = {{Resugaring: lifting evaluation sequences through syntactic sugar}},
url = {http://dl.acm.org/citation.cfm?id=2594291.2594319},
year = {2014}
}
@inproceedings{Herman2010,
abstract = {We present the $\lambda$m-calculus, a semantics for a language of hygienic macros with a non-trivial theory. Unlike Scheme, where programs must be macro- expanded to be analyzed, our semantics admits reasoning about programs as they appear to programmers. Our contributions include a semantics of hygienic macro expansion, a formal definition of $\alpha$-equivalence that is independent of expansion, and a proof that expansion preserves $\alpha$-equivalence. The key technical component of our language is a type system similar to Culpepper and Felleisens shape types, but with the novel contribution of binding signature types, which specify the bindings and scope of a macros arguments.},
author = {Herman, David and Wand, Mitchell},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-540-78739-6\_4},
file = {:Users/matthisk/Library/Application Support/Mendeley Desktop/Downloaded/Herman, Wand - 2008 - A theory of hygienic macros.pdf:pdf},
isbn = {3540787380},
issn = {03029743},
pages = {48--62},
title = {{A theory of hygienic macros}},
url = {http://www.springerlink.com/index/V03K0734Q7217R35.pdf},
volume = {4960 LNCS},
year = {2008}
}
@article{Nystrom2003,
abstract = {Polyglot is an extensible compiler framework that supports the easy creation of compilers for languages similar to Java, while avoiding code dupli- cation. The Polyglot framework is useful for domain-specific languages, explo- ration of language design, and for simplified versions of Java for pedagogical use.We have used Polyglot to implement several major and minor modifications to Java; the cost of implementing language extensions scales well with the degree to which the language differs from Java. This paper focuses on the design choices in Polyglot that are important for making the framework usable and highly exten- sible. Polyglot source code is available.},
author = {Nystrom, N. and Clarkson, M.R. and a.C. Myers},
doi = {10.1007/3-540-36579-6\_11},
file = {:Users/matthisk/Downloads/chp\%3A10.1007\%2F3-540-36579-6\_11.pdf:pdf},
isbn = {9783540009047},
issn = {0302-9743},
journal = {Proceedings of the 12th International Conference on Compiler Construction},
number = {April},
pages = {138--152},
title = {{Polyglot: An extensible compiler framework for Java}},
year = {2003}
}
@article{VandenBrand2002,
abstract = {In this paper we present the fusion of generalized LR parsing and scannerless parsing. This combination supports syntax definitions in which all aspects (lexical and context-free) of the syntax of a language are defined explicitly in one formalism. Furthermore, there are no restrictions on the class of grammars, thus allowing a natural syntax tree structure. Ambiguities that arise through the use of unrestricted grammars are handled by explicit disambiguation constructs, instead of implicit defaults that are taken by traditional scanner and parser generators. Hence, a syntax definition becomes a full declarative description of a language. Scannerless generalized LR parsing is a viable technique that has been applied in various industrial and academic projects.},
author = {van den Brand, M and Scheerder, Jeroen and Vinju, J and Visser, Eelco and Brand, M Van Den},
doi = {http://link.springer.de/link/service/series/0558/bibs/2304/23040143.htm},
file = {:Users/matthisk/Library/Application Support/Mendeley Desktop/Downloaded/van den Brand et al. - 2002 - Disambiguation filters for scannerless generalized LR parsers.pdf:pdf},
isbn = {3-540-43369-4},
journal = {Compiler Construction},
pages = {143--158},
title = {{Disambiguation filters for scannerless generalized LR parsers}},
url = {http://www.springerlink.com/index/03359K0CERUPFTFH.pdf},
year = {2002}
}
@article{Kohlbecker1986,
abstract = {An abstract is not available.},
author = {Kohlbecker, Eugene and Friedman, Daniel P. and Felleisen, Matthias and Duba, Bruce},
doi = {10.1145/319838.319859},
file = {:Users/matthisk/Library/Application Support/Mendeley Desktop/Downloaded/Kohlbecker et al. - 1986 - Hygienic macro expansion.pdf:pdf},
isbn = {0897912004},
journal = {Proceedings of the 1986 ACM conference on LISP and functional programming - LFP '86},
pages = {151--161},
title = {{Hygienic macro expansion}},
url = {http://dl.acm.org/citation.cfm?id=319838.319859},
year = {1986}
}
@book{Smaragdakis2000,
author = {Smaragdakis, Yannis and Batory, Don},
doi = {10.1007/3-540-40048-6\_6},
file = {:Users/matthisk/Google Drive/Studie/Master/Msc Thesis/Papers/Scoping concepts for software generators.pdf:pdf},
keywords = {generation scoping,hygienic macro expansion,program transformations,software generators},
mendeley-tags = {generation scoping,hygienic macro expansion,program transformations,software generators},
pages = {65--78},
title = {{Scoping Constructs for Software Generators}},
year = {2000}
}
@article{Bravenboer2004,
abstract = {Application programmer’s interfaces give access to domain knowledge$\backslash$nencapsulated in class libraries without providing the appropriate$\backslash$nnotation for expressing domain composition. Since object-oriented$\backslash$nlanguages are designed for extensibility and reuse, the language$\backslash$nconstructs are often sufficient for expressing domain abstractions$\backslash$nat the semantic level. However, they do not provide the right abstractions$\backslash$nat the syntactic level. In this paper we describe MetaBorg, a method$\backslash$nfor providing concrete syntax for domain abstractions to application$\backslash$nprogrammers. The method consists of embedding domain-specific languages$\backslash$nin a general purpose host language and assimilating the embedded$\backslash$ndomain code into the surrounding host code. Instead of extending$\backslash$nthe implementation of the host language, the assimilation phase implements$\backslash$ndomain abstractions in terms of existing APIs leaving the host language$\backslash$nundisturbed. Indeed, Meta-Borg can be considered a method for promoting$\backslash$nAPIs to the language level. The method is supported by proven and$\backslash$navailable technology, i.e. the syntax definition formalism SDF and$\backslash$nthe program transformation language and toolset Stratego/XT. We illustrate$\backslash$nthe method with applications in three domains: code generation, XML$\backslash$ngeneration, and user-interface construction.},
author = {Bravenboer, Martin and Visser, Eelco},
doi = {10.1145/1035292.1029007},
file = {:Users/matthisk/Library/Application Support/Mendeley Desktop/Downloaded/Bravenboer, Visser - 2004 - Concrete syntax for objects. Domain-specific language embedding and assimilation without restrictions.pdf:pdf},
isbn = {1581138318},
issn = {0362-1340},
journal = {Proceedings of the 19th ACM SIGPLAN Conference on Object-Oriented Programing, Systems, Languages, and Applications (OOPSLA’04},
keywords = {cific languages,concrete,domain-spe-,embedded lan-,extensible syntax,guages,meta programming,metaborg,rewriting,sdf,stratego,syntax extension},
pages = {365--383},
title = {{Concrete syntax for objects. Domain-specific language embedding and assimilation without restrictions}},
year = {2004}
}
@article{Salomon1989,
author = {Salomon, D. J. and Cormack, G. V.},
doi = {10.1145/74818.74833},
file = {:Users/matthisk/Library/Application Support/Mendeley Desktop/Downloaded/Salomon, Cormack - 1989 - Scannerless NSLR(1) parsing of programming languages.pdf:pdf},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
number = {7},
pages = {170--178},
title = {{Scannerless NSLR(1) parsing of programming languages}},
volume = {24},
year = {1989}
}
@article{Brand2001,
author = {Brand, M G J Van Den and Deursen, a Van and Heering, J and Jong, H a De and Jonge, M De and Kuipers, T},
file = {:Users/matthisk/Downloads/chp\%3A10.1007\%2F3-540-45306-7\_26.pdf:pdf},
journal = {Compiler Construction},
pages = {365--370},
title = {{The ASF + SDF Meta-Environment: a Component-Based Language Development Environment}},
year = {2001}
}
@article{Herman2010a,
abstract = {We present the $\lambda$m-calculus, a semantics for a language of hygienic macros with a non-trivial theory. Unlike Scheme, where programs must be macro- expanded to be analyzed, our semantics admits reasoning about programs as they appear to programmers. Our contributions include a semantics of hygienic macro expansion, a formal definition of $\alpha$-equivalence that is independent of expansion, and a proof that expansion preserves $\alpha$-equivalence. The key technical component of our language is a type system similar to Culpepper and Felleisens shape types, but with the novel contribution of binding signature types, which specify the bindings and scope of a macros arguments.},
author = {Herman, David and Wand, Mitchell},
file = {:Users/matthisk/Library/Application Support/Mendeley Desktop/Downloaded/Herman, Wand - 2010 - A Theory of Typed Hygienic Macros.pdf:pdf},
journal = {Proceedings of the 17th European Symposium on Programming},
pages = {48},
title = {{A Theory of Typed Hygienic Macros}},
url = {http://www.springerlink.com/index/V03K0734Q7217R35.pdf},
volume = {4960},
year = {2010}
}
@article{Heering1989,
author = {Heering, Jan and Hendriks, P R H and Klint, Paul and Rekers, Jan},
doi = {http://doi.acm.org/10.1145/71605.71607},
file = {:Users/matthisk/Library/Application Support/Mendeley Desktop/Downloaded/Heering et al. - 1989 - The syntax definition formalism SDF - reference manual.pdf:pdf},
issn = {0362-1340},
journal = {SIGPLAN Notices},
number = {11},
pages = {43--75},
title = {{The syntax definition formalism SDF - reference manual}},
volume = {24},
year = {1989}
}
@article{Cardelli1994,
abstract = {A frequent dilemma in programming language design is the choice between a language with a rich set of notations and a small, simple core language. We address this dilemma by proposing extensible grammars, a syntax-definition formalism for incremental language extensions and restrictions. The translation of programs written in rich object languages into a small core language is defined via syntax-directed patterns. In contrast to macroexpansion and program-rewriting tools, our extensible grammars respect scoping rules. Therefore, we can introduce binding constructs while avoiding problems with unwanted name clashes. We develop extensible grammars and illustrate their use by extending the lambda calculus with let-bindings, conditionals, and constructs from database programming languages, such as \{SQL\} query expressions. We then give a formal description of the underlying rules for parsing, transformation, and substitution. Finally, we sketch how these rules are exploited in an implementati...},
author = {Cardelli, Luca and Matthes, Florian and Abadi, Martin and Taylor, Robert W},
file = {:Users/matthisk/Library/Application Support/Mendeley Desktop/Downloaded/Cardelli et al. - 1994 - Extensible Syntax with Lexical Scoping.pdf:pdf},
title = {{Extensible Syntax with Lexical Scoping}},
year = {1994}
}
@article{Visser2001,
author = {Visser, Eelco},
doi = {10.1016/S1571-0661(04)00270-1},
file = {:Users/matthisk/Google Drive/Studie/Master/Msc Thesis/Papers/A survey of rewriting strategies in program transformation systems.pdf:pdf},
issn = {15710661},
journal = {Electronic Notes in Theoretical Computer Science},
month = dec,
pages = {109--143},
title = {{A Survey of Rewriting Strategies in Program Transformation Systems}},
url = {http://linkinghub.elsevier.com/retrieve/pii/S1571066104002701},
volume = {57},
year = {2001}
}
@article{Klinta,
author = {Klint, Paul and van der Storm, Tijs and Vinju, Jurgen},
file = {:Users/matthisk/Google Drive/Studie/Master/Msc Thesis/Papers/Rascal.pdf:pdf},
title = {{RASCAL : a Domain Specific Language for Source Code Analysis and Manipulation}}
}
@article{Leavenworth1966,
abstract = {A translation approach is described which allows one to extend the syntax and semantics of a given high-level base language by the use of a new formalism called a syntax-macro. Syntax-macros define string transformations based on syntactic elements of the base language. Two types of macros are discussed, and examples are given of their use. The conditional generation of macros based on options and alternatives recognized by the scan are also described.},
author = {Leavenworth, B. M.},
doi = {10.1145/365876.365879},
file = {:Users/matthisk/Library/Application Support/Mendeley Desktop/Downloaded/Leavenworth - 1966 - Syntax macros and extended translation.pdf:pdf},
issn = {00010782},
journal = {Communications of the ACM},
number = {11},
pages = {790--793},
title = {{Syntax macros and extended translation}},
volume = {9},
year = {1966}
}
@article{Weise1993,
abstract = {Lisp has shown that a programmable syntax macro system acts as an adjunct to the compiler that gives the programmer important and powerful abstraction facilities not provided by the language. Unlike simple token substitution macros, such as are provided by CPP (the C preprocessor), syntax macros operate on Abstract Syntax Trees (ASTs). Programmable syntax macro systems have not yet been developed for syntactically rich languages such as C because rich concrete syntax requires the manual construction of syntactically valid program fragments, which is a tedious, difficult, and error prone process. Also, using two languages, one for writing the program, and one for writing macros, is another source of complexity. This research solves these problems by having the macro language be a minimal extension of the programming language, by introducing explicit code template operators into the macro language, and by using a type system to guarantee, at macro definition time, that all macros and macro functions only produce syntactically valid program fragments. The code template operators make the language context sensitive, which requires changes to the parser. The parser must perform type analysis in order to parse macro definitions, or to parse user code that invokes macros.},
author = {Weise, Daniel and Crew, Roger},
doi = {10.1145/173262.155105},
file = {:Users/matthisk/Library/Application Support/Mendeley Desktop/Downloaded/Weise, Crew - 1993 - Programmable syntax macros.pdf:pdf},
isbn = {0-89791-598-4},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
number = {6},
pages = {156--165},
title = {{Programmable syntax macros}},
volume = {28},
year = {1993}
}
@inproceedings{Disney2014,
address = {New York, New York, USA},
author = {Disney, Tim and Faubion, Nathan and Herman, David and Flanagan, Cormac},
booktitle = {Proceedings of the 10th ACM Symposium on Dynamic languages - DLS '14},
doi = {10.1145/2661088.2661097},
file = {:Users/matthisk/Google Drive/Studie/Master/Msc Thesis/Papers/Sweeten your javascript.pdf:pdf},
isbn = {9781450332118},
keywords = {hygiene,in a language with,javascript,macros,manip-,parentheses like scheme,simple,subexpressions,ulating unparsed subexpressions is},
pages = {35--44},
publisher = {ACM Press},
title = {{Sweeten your JavaScript}},
url = {http://dl.acm.org/citation.cfm?doid=2661088.2661097},
year = {2014}
}
@article{Fowler2005,
abstract = {Most new ideas in software developments are really new variations on old ideas. This article describes one of these, the growing idea of a class of tools that I call Language Workbenches - examples of which include Intentional Software, JetBrains's Meta Programming System, and Microsoft's Software Factories. These tools take an old style of development - which I call language oriented programming and use IDE tooling in a bid to make language oriented programming a viable approach. Although I'm not enough of a prognosticator to say whether they will succeed in their ambition, I do think that these tools are some of the most interesting things on the horizon of software development. Interesting enough to write this essay to try to explain, at least in outline, how they work and the main issues around their future usefulness},
author = {Fowler, Martin},
doi = {http://www.martinfowler.com/articles/languageWorkbench.html},
file = {:Users/matthisk/Library/Application Support/Mendeley Desktop/Downloaded/Fowler - 2005 - Language workbenches The killer-app for domain specific languages.pdf:pdf},
isbn = {4567890123456},
journal = {Accessed online from: http://www. martinfowler. com/articles/languageWorkbench. html},
pages = {1--27},
title = {{Language workbenches: The killer-app for domain specific languages}},
url = {http://www.issi.uned.es/doctorado/generative/Bibliografia/Fowler.pdf},
year = {2005}
}
@inproceedings{Pfenning1988,
author = {Pfenning, F. and Elliot, C.},
booktitle = {Proceedings of the ACM SIGPLAN 1988 conference on Programming Language design and Implementation - PLDI '88},
doi = {10.1145/53990.54010},
file = {:Users/matthisk/Library/Application Support/Mendeley Desktop/Downloaded/Pfenning, Elliot - 1988 - Higher-order abstract syntax.pdf:pdf},
isbn = {0897912691},
pages = {199--208},
title = {{Higher-order abstract syntax}},
url = {http://portal.acm.org/citation.cfm?doid=53990.54010},
year = {1988}
}
@article{Visser20024,
abstract = {Stratego/XT is a framework for the development of transformation$\backslash$n$\backslash$nsystems aiming to support a wide range of program transformations. The framework$\backslash$n$\backslash$nconsists of the transformation language Stratego and the XT collection of$\backslash$n$\backslash$ntransformation tools. Stratego is based on the paradigm of rewriting under the$\backslash$n$\backslash$ncontrol of programmable rewriting strategies. The XT tools provide facilities$\backslash$n$\backslash$nfor the infrastructure of transformation systems including parsing and prettyprinting.},
author = {Visser, Eelco},
doi = {10.1007/b98156},
file = {:Users/matthisk/Library/Application Support/Mendeley Desktop/Downloaded/Visser - 20024 - Program transformation with StrategoXT. rules, strategies, tools, and systems in Stratego.pdf:pdf},
isbn = {3-540-22119-0},
journal = {Domain-Specific Program Generation},
number = {February},
pages = {315--349},
title = {{Program transformation with Stratego/XT. rules, strategies, tools, and systems in Stratego}},
url = {http://scholar.google.com/scholar?hl=en\&btnG=Search\&q=intitle:Program+Transformation+with+Stratego+/+XT+:+Rules+,+Strategies+,+Tools+,+and+Systems\#6},
year = {20024}
}
